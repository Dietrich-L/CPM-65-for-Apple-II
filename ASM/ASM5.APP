GHEX	LDA #4
	STA HEXCNT
	JSR RESOPB
	LDA #SP
	STA OPRT
	LDY LINPNT
GHEX4	LDA (LINE),Y
	BEQ GHEX1
	INY
	JSR ASCHEX
	BCS GHEX1
	LDX #4
GHEX3	ASL OPERB
	ROL OPERB+1
	DEX
	BNE GHEX3
	ORA OPERB
	STA OPERB
	DEC HEXCNT
	BNE GHEX4
GHEX5	LDA OPERB
	LDX OPERB+1
	STY LINPNT
	CLC
	RTS

GHEX1	STA OPRT
	LDA HEXCNT
	BNE GHEX5
	STY LINCNT
	JMP SYNERR


RESOPB	LDA #0
	STA OPERB
	STA OPERB+1
	RTS


ASCHEX	TAX
	JSR CHRCHK
	BCS ASCHE1
	CMP #'G
	BCS ASCHE1
	CMP #'A
	BCS ASCHE2
ASCDEC	CMP #$3A
	BCS ASCHE1
	CMP #'0
	BCC ASCHE1
ASCHE3	AND #$0F
	CLC
	RTS

ASCHE1	TXA
	SEC
	RTS

ASCHE2	SBC #7
	BNE ASCHE3


GBIN	LDA #16
	STA HEXCNT
	LDA #SP
	STA OPRT
	JSR RESOPB
	LDY LINPNT
GBIN2	LDA (LINE),Y
	BEQ GBIN1
	INY
	JSR ASCBIT
	BCS GBIN1
	ASL OPERB
	ROL OPERB+1
	ORA OPERB
	STA OPERB
	DEC HEXCNT
	BNE GBIN2
GBIN3	LDA OPERB
	LDX OPERB+1
	STY LINPNT
	CLC
	RTS

GBIN1	STA OPRT
	LDA HEXCNT
	BNE GBIN3
	STY LINPNT
	JMP SYNERR


ASCBIT	CMP #'0
	BEQ ASCBI1
	CMP #'1
	BEQ ASCBI1
	SEC
	RTS

ASCBI1	AND #$01
	CLC
	RTS


GDEC	JSR RESOPB
	LDX #0
GDEC4	INX
	LDA LBLSTR,X
	JSR ASCDEC
	BCS GDEC2
	STA HEXCNT
	ASL OPERB
	ROL OPERB+1
	BCS GDEC3
	LDA OPERB
	LDY OPERB+1
	ASL OPERB
	ROL OPERB+1
	BCS GDEC3
	ASL OPERB
	ROL OPERB+1
	BCS GDEC3
	ADC OPERB
	STA OPERB
	TYA
	ADC OPERB+1
	STA OPERB+1
	BCS GDEC3
	LDA HEXCNT
	ADC OPERB
	STA OPERB
	BCC GDEC1
	INC OPERB+1
	BEQ GDEC3
GDEC1	CPX LBLSTR
	BCC GDEC4
	LDA OPERB
	LDX OPERB+1
	CLC
	RTS

GDEC3	LDA #OFLOW
	SEC
	RTS

GDEC2	LDA #ILLDEC
	SEC
	RTS


CHRCHK	CMP #'A 	;CHECK FOR VALID CHR
	BCC CHRCH1
	CMP #'[
	BCS CHRCH3
	RTS

CHRCH3	CMP #'a
	BCC CHRCH1
	CMP #'{
	BCS CHRCH1
	AND #$5F	;LOWER TO UPPER CASE
	RTS

CHRCH1	STY YTEMP
	LDY #ADMTAB-KEYTAB-1
CHRCH2	CMP KEYTAB,Y
	BEQ CHRCH4
	DEY
	BPL CHRCH2
	LDY YTEMP
	SEC
	RTS

CHRCH4	LDY YTEMP
	CLC
	RTS

;------------------------------------

LBLPUT	JMP LBLINI	;VECTOR FOR LBLPUT

LBLRST	LDA #LBLINI	;PATCH JMP LBLPUT
	STA LBLPUT+1
	LDA #LBLINI/256
	STA LBLPUT+2
	LDA BDOS+1	;HEAP=BDOS-1
	LDY BDOS+2
	STA HEAP
	STA HIMEM
	STY HEAP+1
	STY HIMEM+1
	SEC		;place NIL entry in ROOT
	SBC #8
	STA ROOT
	DEY
	STY ROOT+1
	LDA #0
	LDY #7
LBLRS1	STA (ROOT),Y
	DEY
	BPL LBLRS1
	LDY #6
	LDA #$81
	STA (ROOT),Y
	RTS


LBLINI	JSR LBLSTO	;put 1. label to label tree
	BCS LBLINX
	LDA NOD		;set ROOT to 1. label
	STA ROOT
	LDA NOD+1
	STA ROOT+1
	LDA #LBLPU	;PATCH JMP LBLPUT
	STA LBLPUT+1
	LDA #LBLPU/256
	STA LBLPUT+2
	CLC
LBLINX	RTS


LBLPU	JSR SEARCH	;FIND LEAF
	BCC LBLPU1
	STY NODLEN	;SAVE NOD
	LDA NOD
	STA PNOD
	LDA NOD+1
	STA PNOD+1
	JSR LBLSTO
	BCS LBLPU2
	LDY NODLEN	;SET PNOD
	LDA NOD
	STA (PNOD),Y
	INY
	LDA NOD+1
	STA (PNOD),Y
	CLC
LBLPU2	RTS

LBLPU1	LDA #DUPLBL	;DUPLICATE LABEL
	SEC
	RTS


LBLSET	LDY #4		;SET VALUE
	STA (NOD),Y
	INY
	TXA
	STA (NOD),Y
	INY
	LDA (NOD),Y	;RESET EMPTY FLAG
	BPL LBLSE1
	AND #$7F
	STA (NOD),Y
	CLC
	RTS

LBLSE1	LDA #DUPVAL
	SEC
	RTS


LBLOUT	LDY #6
	LDA (NOD),Y
	BMI LBLOU1
	DEY
	LDA (NOD),Y
	TAX
	DEY
	LDA (NOD),Y
	CLC
	RTS

LBLOU1	LDA #NOVAL
	SEC
	RTS


LBLSTO	CLC		;store new label
	LDA HEAP	;calculate room
	LDY HEAP+1
	SBC LBLSTR	;NODSTR = HEAP-LBLSTR-1
	BCS LBLST5
	DEY
LBLST5	STA NODSTR
	STY NODSTR+1
	SEC		;NOD = A/Y-6
	SBC #6
	BCS LBLST6
	DEY
LBLST6	STA NOD
	STA HEAP	;HEAP=NOD
	STY NOD+1
	STY HEAP+1
	CPY CODE+1	;HEAP > CODE ?
	BNE LBLST1
	CMP CODE
	BCC LBLST2
	BEQ LBLST2
LBLST1	LDA LBLSTR
	TAY
	ORA #$80	;SET EMPTY FLAG
	PHA
LBLST3	LDA LBLSTR,Y	;SET LABEL
	STA (NODSTR),Y
	DEY
	BNE LBLST3
	PLA
	STA (NODSTR),Y
	TYA		;RESET VECTORS
	LDY #5
LBLST4	STA (NOD),Y
	DEY
	BPL LBLST4
	CLC
	RTS

LBLST2	LDA #MEMOVL	;MEMORY FULL
	SEC
	RTS


SEARCH	LDA ROOT	;SEARCH LABEL IN LBLSTR
	LDX ROOT+1	;NOD=ROOT
SEARC4	JSR SETNOD
	JSR LBLCHK	;C=0 found, C=1 Y=index to next NOD vector
	BCC SEARC5	;FOUND
SEARC1	LDA (NOD),Y
	TAX
	BNE SEARC2
	DEY
	LDA (NOD),Y
	BNE SEARC4	;if (NOD <> $0000 then next NOD
	SEC		;NOT FOUND
SEARC5	RTS

SEARC2	DEY
	LDA (NOD),Y	;SET FOR NEXT NOD
	JMP SEARC4


LBLCHK	LDY #0		;CHECK LBLSTR VS. NODSTR
	LDA (NODSTR),Y	;SET NODLEN
	AND #$1F	;mask flag bits
	STA NODLEN
	LDA LBLSTR
	STA LBLLEN
LBLCH4	INY		;COMPARE
	LDA LBLSTR,Y
	CMP (NODSTR),Y
	BEQ LBLCH1
	BCS LBLCH2
LBLCH6	LDY #1		;<
	SEC
	RTS

LBLCH1	DEC LBLLEN
	BEQ LBLCH3
	DEC NODLEN
	BNE LBLCH4	;next chr
LBLCH2	LDY #3		;>
	SEC
	RTS

LBLCH3	DEC NODLEN
	BNE LBLCH6	;<
	CLC		;=
	RTS


G1LBL	LDA HEAP	;GET 1. LABEL
	LDX HEAP+1
	JMP GNLBL2


GNLBL	LDY #0		;GET NEXT LABEL
	LDA (NODSTR),Y
	AND #$1F	;MASK FLAGS
	SEC
	ADC NODSTR
	STA NOD
	LDA NODSTR+1
	ADC #0
	TAX
	LDA NOD 	;A/X=NEXT NOD
GNLBL2	JSR SETNOD
	LDA NOD+1
	CMP HIMEM+1
	BCC GNLBL1
	LDA NOD
	CMP HIMEM
GNLBL1	RTS


PLUS	CLC		;OPERA+OPERB
	LDA OPERA
	ADC OPERB
	STA OPERA
	LDA OPERA+1
	ADC OPERB+1
	STA OPERA+1
	CLC		;NO OVERFLOW
	RTS


MINUS	SEC		;OPERA-OPERB
	LDA OPERA
	SBC OPERB
	STA OPERA
	LDA OPERA+1
	SBC OPERB+1
	STA OPERA+1
	CLC		;NO UNDERFLOW
	RTS


MULT	JSR COPATX	;OPERA*OPERB
	LDX #16 	;16 BIT MULT
MULT1	DEX
	BEQ MULTX
	LSR OPERX+1	;SHR X
	ROR OPERX
	BCS MULT2
MULT3	ASL OPERB	;SHL B
	ROL OPERB+1
	JMP MULT1

MULT2	JSR PLUS	;A+B
	JMP MULT3

MULTX	CLC		;MOD 16 BIT
	RTS


DIV	JSR COPATX	;A/B 16 BIT DIV
	LDX #16 	;16 BIT
	LDY #0
	LDA OPERX+1	;NORMALIZE X
	BMI DIV3
DIV1	DEY
	DEX
	BEQ DIV2	;A=0
	ASL OPERX	;SHL X
	ROL OPERX+1	;NORMALIZE X
	BPL DIV1
	LDX #16
DIV3	LDA OPERB+1
	BMI DIV6	;NORMALIZE B
DIV8	INY
	DEX
	BEQ DIV5	;DIVISION BY 0
	ASL OPERB	;SHL B
	ROL OPERB+1
	BPL DIV8
DIV6	TYA		;B>X?
	BMI DIV2
	BNE DIV4
	JSR DIVSUB	;X-A
	BCC DIV2
	BCS DIV7
DIV4	JSR DIVSUB	;X-A
DIV7	ROL OPERA	;SHIFT BIT IN A
	ROL OPERA+1
	LSR OPERB+1	;SHR B
	ROR OPERB
	DEY		;SHIFT COUNT
	BPL DIV4
DIV2	CLC
	RTS

DIV5	LDA #$AA
	STA OPERA
	STA OPERA+1
	LDA #DIV0
	SEC
	RTS


DIVSUB	SEC		;X-B
	LDA OPERX
	SBC OPERB
	TAX
	LDA OPERX+1
	SBC OPERB+1
	BCC DIVSUB1
	STA OPERX+1
	STX OPERX
DIVSUB1	RTS


SETNOD	STA NOD 	;SET NOD
	STX NOD+1
	CLC		;SET NODSTR
	ADC #6
	STA NODSTR
	TXA
	ADC #0
	STA NODSTR+1
	RTS


COPATX	LDA OPERA	
	STA OPERX	;X=A
	LDA OPERA+1
	STA OPERX+1
	LDA #0		;A=0
	STA OPERA
	STA OPERA+1
	RTS


HEXDEC	STA OPERX		;HEX TO DECIMAL CONVERSION
	STY OPERX+1
	LDX #4
HEXDEC1	JSR DIV10		;/10 RESIDUAL IN A
	ORA #$30
	STA LBLSTR,X
	DEX
	BPL HEXDEC1
	RTS


	APP ASM6.APP

